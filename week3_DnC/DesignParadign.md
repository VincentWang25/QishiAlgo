Design Paradigm:
- (1)Search and enumeration
    - DFS/BFS
    - backtracking
    - two pointers/pruning(clever way of searching by eliminating a large search space)
- (2)Divide and conquer/decrease and conquer
    - binary search as decrease and conquer, find sth in one half + find sth in the other half(sorted so only one half needed)
- (3)Transform and conquer
    - eg. sort before attacking the problem of three sum
- (4)Time space trade-off
    - memoization
    - hash tables
- (Randomized algorithms,...)
- Greedy


Problem Classification:
1. (15) 3Sum: Transform and conquer, time space trade-off
2. (16) 3Sum Closet: Transform and conquer, search and enumeration (two pointers)
3. (18) 4Sum: Transform and conquer, time space trade-off
4. (31) Next Permutation
5. (45) Jump Game II: Greedy
6. (75) Sort Colors: two pointers
7. (86) Partition List: two pointers
8. (106) Construct Binary Tree from Inorder and Postorder Traversal: Divide and conquer
9. (109) Convert Sorted List to Binary Search Tree: Divide and conquer
10. (114) Flatten Binary Tree to Linked List: DFS
11. (117) Populating Next Right Pointers in Each Node II: DFS
12. (127) Word Ladder: BFS
13. (152) Maximum Product Subarray: dynamic programming
14. (190) Reverse Bits: Bit Manipulation
15. (210) Course Schedule II: DFS, Topological sort